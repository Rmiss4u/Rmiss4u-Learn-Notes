cs
点乘 计算两者向量的方位关系 数值为a投射b上的长度
     寻找两个向量(视角)上的方位关系 比如是否平行 是否方向相反 然后是否在可见范围内(比如夹角)
     点乘角度(cos) 点乘角度
叉乘 计算两者向量所成平面的法向量 数值为所称平行四边形的面积
     叉乘方向 光反射问题 相对位置 顺时针/逆时针位置
     三线共面 旋转力的力矩
归一化 将向量模长改为1 normalize
四元数 坐标三数+转角

数组 静态定义有序连续的元素集合
动态数组 vector 动态改变长度的数组vector
链表 list 非连续存储的有序集合
堆栈 stack 后进先出
队列 queue 先进先出
双端队列 deque 两端插入移除的集合
优先队列 priority queue 高效弹出优先最高元素
树 树形结构
二叉查找树 BST 二叉分树 例红黑树 伸展树 AVL树
二叉堆 完全二叉树i二狗 数组存储 根节点最值 一般用于优先队列
字典 dictionary 键值对
集合 set 没有重复的容器
图 graph 节点集合 节点之间任意单向或双向连接
有向非循环图 节点单向连接无循环
操作 插入 移除 顺序访问迭代 随机访问 查找 排序

cpp
vector怎么实现动态扩容
答 如果扩容就扩两倍
数组和指针的区别
答 数组是存储数据指针是存储保存数据的地址
   指针是间接访问数组直接访问

sf
查找一组数据中出现次数为2的数
答 排序后位运算 / set集合查找
判断链表中是否有环存在
答 快慢双指针 相遇点为环口
树的遍历方式
答 四种 前中后 层序
万向节锁
答 例 x旋转±90之后 自身z和世界y重合 无法自由旋转
     使用欧拉角三个方位旋转产生的缺点
     方法:zxy顺序旋转 / 以unity的内置函数进行操作
欧拉角
答 xz绕自身 y绕世界 eulerAngles
值类型和引用类型
答 c#的值类型继承自system.valuetype  引用继承自.object
大顶堆(第K个最大的数)
答 类似快排思想 但只在二分数据中进行计算

this指针存在寄存器
c* pc=new c。然后b* pb=dynamic_cast<b*>(pc)，问此时指针pb和pc指向是不是同一个地址，多继承下的对象模型，直觉我就回答指针偏移

协程 
IEnumerator 持续值行到完全结束

结构体字节对齐 如何自定义对齐
cpu访问数据效率 以#pragma pack()设定

虚函数 纯虚函数
基类中定义(程序多态)
纯虚数用于规范派生类

套接字编程流程 哪几个方法 套接字设置选项

unity底层内存管理

cpp虚函数机制

TCP UDP 包头区别
两种传输层协议 
TCP连接三次握手 断开四次握手
UDP面向报文
TCP 面向连接 传输可靠 一对一 字节流 首部20~60字节 文件传输
UDP 无连接 不可靠传输 一对一 多对一 一对多多对多 面向报文 首部8字节 视频通话实时应用

光栅化渲染
图形上的抗锯齿方式

shader
着色器 渲染技术

3D物体映射到2D屏幕上
2方法
方法1 camera照射3D模型 进行组件设置 切换为2D平面
方法2 为A添加组件UI viewport

unity为什么要打图集
DrawCall是openGL描绘次数 打图集是为了优化程序性能

最小栈
栈反复压入存入数据 每次压入计算二栈和压入数据的最值 取最小压入二栈

矩阵逆 逆矩阵性质 求矩阵的行列式
A和A逆积为单位阵 
计算可逆 伴随矩阵/行列式 或者 增广矩阵 或者 LU分解法 或者 QR分解法

稳定排序的排序算法
冒泡排序、直接插入排序(猜测 选择排序)、折半插入排序、归并排序

自上而下分治算法思想有什么
归并算法(?)

cpp三大特性理解 缺点是什么
封装 继承 多态 复杂学习周期长 stl库繁杂

cpp特性 override final lambda
略

什么时候调用不到析构函数
无意从它派生类
没有在堆上实例化
无意存储在超类的指针中 

虚函数表在哪
生成类对象的空间里

new的底层
operator new -> malloc
调用构造函数
调用析构函数
释放空间operator delete----->free

O1查找操作符合条件的数据结构
？

哈希表创建的注意点
不能大于哈希表最大值HASH_TABLE_SIZE

游戏架构


64位和32位区别
cpu制程的性能 
32位只能4G 线程不能超过32
64位16T 能兼容32位的软件
硬件兼容要求不同

设计一个断线重连机制


实现栈


矩阵旋转
坐标矩阵矩阵乘以旋转系数

跳表
unordered_map map实现
memcpy memmove

算法和数据结构：数组、链表、二叉树、堆栈、排序算法、B+/B-树、DP（动态规划）等；
计算机网络：HTTP、DNS、ARP、TCP、IP、ICMP、UDP等；
操作系统：IO、存储器、多线程/多进程、同步机制、处理器调度及死锁、设备管理、通道等；
计算机组成原理：冯诺依曼计算机组成、计算机层次结构、计算机性能指标等；


一面
问到如何用navmesh动态寻路，我说我是把每个房间烘焙好再链接房间预制体的。
问子弹如何判断集中，讲了下给玩家和敌人不同的tag，子弹碰撞的时候检测碰撞的物体和目标物体tag是否一致，防止敌人攻击敌人。
提到子弹用了粒子效果，问了下子弹没有打到敌人怎么办，答子弹必会撞到墙，但可以用onBecameInvisiable，在不可见时销毁。
问你的房间每一个都是重新生成的吗，答是，感觉他想问对象池，就讲了下对象池的思路。
提到防止房间重叠是在每次要放一个新房间是遍历所有已有房间判断，
问有没有更好的方法，之前准备过就讲了自己的思路，面试官说我的方法是bitset我说对对对。
操作系统：
经典进程和线程；线程间通信，互斥量，信号量
问线程的挂起和执行是怎么判断的
问线程在任何时间都可以被阻塞或者挂起吗
C++：
怎么动态分配内存？ 
new，在内存上的哪个区？ 
堆，怎么删除？ 
delete，delete[]，讲一下单例的实现方式？
讲的懒汉式
下线程安全
哪些函数不能是虚的 只说了构造
网络：
经典TCP和UDP，拥塞控制详细讲了下。
DNS是什么协议？udp
ping呢？ icmp
红黑树问了下，问我最坏情况下的搜索复杂度是多少，中间有引导我说是什么数列
冯和布林冯的区别

二面
c++：
c++不同于其他语言的特性，讲了指针，智能指针。
引用，右值引用的意义
内存布局
内存对齐
函数调用的过程。
多线程带来了什么问题，讲讲你知道的锁。
如果联机要考虑啥？说了同步，状态同步帧同步，在服务器计算和在客户端计算，
详细讲讲在服务器计算和在客户端计算的优缺点。从服务端计算的压力，延迟的考虑，安全性
让你实现网络同步，用什么协议.答用在应用层优化的udp，简单说了下
两个10G的文件，200m内存，排序。答用堆每次排出200m。答的不是很好吧，而且没考虑数据的重复，一开始的思路还有点混乱。
如果不让你用UI组件，在unity中怎么展现一张图片？
答把他贴到一个方块上，摄像机对准这个方块呗。
追问应该咋贴，我说应该是在mesh组件上加个贴图吧
追问怎么确定每个点的颜色，在渲染的什么步骤？ 我把光栅化确定uv坐标，插值啥的都讲了一遍。
他又问我这个上色的过程叫啥？ 我才反应过来原来是要问shader。

三面
照常自我介绍
怎么求一条直线和球相交，我说如果球是由隐式表达式定义的话可以直接用公式求直线和球的交点，
然后准备说如果球是由三角形构成的话怎么做被打断，说球就是隐式表达式的，用公式求交具体的式子
游戏用UDP还是TCP？
我直接说UDP。
怎么实现？
有序稳定安全性上扯了扯。
他问有没有了解过安全UDP？
我说知道谷歌开发了个忘了叫啥的，国内有个KDP。
平时玩啥游戏。
想做什么类型的，我说想做fps，他说具体方向呢，我说先从ui逻辑战斗逻辑做起熟悉开发流程吧。
中间有提到简历上写的navmesh寻路我寻思这个我会结果他没问。
看我用到了blend-tree，问我人物的脚怎么踩在地面上的石头上，我说是IK吗？
又硬扯到了我自己的blendtree实现，讲了一会。
看我写过网站，问我什么什么32位系统的初始内存空间是多大？
是不是4G啊，我当时也没听清以为是给进程分配的初始空间，也说不会。
行为树和状态机的区别，行为树没用过，扯了会状态机。
自己图形学看到光线追踪，他问光栅化和光线追踪最大的区别是什么。

腾讯微信游戏
零面：
检查二叉树是否平衡、
2个字符串大数的除法、
实现堆栈使其内部的pushpopmax方法复杂度为O1、
若干个数组的所有可能组合、
圆和OBB相交检测

一面：
dx怎么实现你说的那个雾效？
（本人对简历项目准备得不充分，连实现的代码都忘了）
公告板？
（说实现）
介绍一下昨天的obb碰撞检测怎么做？
（一行代码Vector2.Max()就能解决的事）

二面：
然后你在场景里弄一个球壳体把这个摄像机包围住，然后把VR视频的纹理渲染到球的内表面就好了）
怎么实现天空盒？
（映射到一个正方体，然后内套一个球，球的纹理根据视线去将对应的正方体纹理映射到自己身上）
怎么实现会动的天空盒？白云飘的那种效果？
（直接上体积云体积雾吧）//粒子特效 或者 指数级高度雾
纹理压缩？
（mipmap）纹理映射
碰撞检测优化？
（八叉树）四叉树
如何解决一个物体可能被多个叶子节点记录这个问题？
（空间划分改物体划分BVH）

链表穿针引线、
树最大深度、class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
多个数排列起来成一个数使其最小


Q：从 cpp 源代码到 exe 经过了哪些过程？

编译生成汇编代码、汇编生成机器代码、链接拼接各个模块

追问：编译之前有没有要做的？

处理各种宏和 include，将引用的代码拼接过来，对宏进行替换


Q：c 和 c++ 差异？c++ 执行更快吗？

c++ 能通过继承、虚函数等机制实现多态

c 运行更快


Q：STL 中 vector 不断 push，内存上会有何变化？用指针指向 vector 元素应该注意什么？

达到阈值内存就扩容两倍（扩容倍数和编译器版本有关）

注意扩容后数据搬离，指针指空，变为野指针


Q：怎么理解 c++ 的虚函数？什么是纯虚函数？

能够允许通过基类指针调用派生类函数

纯虚函数必须由子类实现


Q：为何析构函数可以为虚？子类不实现析构函数会怎样？

鼓励子类实现，以在析构函数中释放资源。不实现的话会调用父类的析构函数，可能造成子类资源未释放导致内存泄漏


Q：谈谈 static 关键字怎么用，有何效果？

修饰变量：只能在同一文件中被访问的静态变量

修饰函数：可以不实例化某个类，就调用该类的 static 函数


Q：进程和线程有何不同？线程同步有哪些方式？一个线程有几个栈？有没有无锁线程同步方式？

进程是资源分配的最小单位，线程是处理机调度的最小单位

线程有独立的调用栈

无锁队列（这个当时没答出来）


Q：分别谈一谈 PBR 里面的 D、F、G 项？菲涅尔项会带来怎样的视觉效果？

这里答得不太好，面试官想问物理意义，我答成公式组成了。应该这么答

D 表示反射光强度在法线附件的分布，微平面向量和面法向越接近，强度越大。通过粗糙度改变波瓣形状

F 表示菲涅尔效应，掠视金属时反射较多的光而俯视时反射光较少

G 表示掠视时的几何遮蔽，通过史密斯法叠加入射和出射两个方向


Q：PBR 材质贴图很多，纹理槽位不够应该怎么处理？

合并多个属性到一个通道，比如 roughness 和 metallic 可以存在 8 bit 纹理的高低 4 bit 上

追问：还有别的方法？

虚拟纹理，将小贴图合并成大贴图，按需调入


Q：PBR 贴图格式需要注意什么？

albedo 可以 sRGB 格式，而 roughness 和 metallic 需要保存在线性空间


Q：GPU 渲染管线有哪些流程？

应用程序、几何处理、投影、裁剪、光栅化、像素着色、各种 test


Q：除了 fs、vs 还有哪些着色器？它们的作用？写代码时用过哪些着色器？

几何、细分、计算着色器

用 compute shader 写过 cluster lighting，每个 cluster 分配一个 GPU 线程去做光源剔除


Q：延迟渲染的优缺点是什么？在移动端实现需要注意什么？

优点：计算多光源光照时只用一个 pass，和场景复杂度无关

缺点：gbuffer 显存带宽，不支持 MSAA，透明物体渲染难以处理

在移动端可以将多个 gbuffer 压缩成一张纹理（参考 CryEngine 的 MicroGBuffer 技术）

追问：还有呢？

没答出来，面试官提示苹果的 metal 有实现移动端 gbuffer 的优化，通过 Lossy compression 压缩 Render Target 的大小以节省显存带宽


Q：知道伽马矫正吗？说说何时切换到伽马空间？

显示器电压和亮度的变换不是线性的，而是 gamma 2.2

在线性空间计算光照、颜色，输出的时候要做一次 gamma 0.454 抵消显示器的变换


Q：顶点属性太多，槽位不够怎么办？

这个也没答好。答案应该是可以使用一个大 buffer 存 struct 然后顶点属性只用存 buffer 的索引


Q：模型面数太多应该怎么优化？

降模、LOD、使用顶点索引

当时没想到的：其实可以程序化生成。比如地形，存地形网格的开销很大


Q：vs 开销很大怎么办？fs 开销很大呢？

vs：避免连续矩阵乘法，可以在 cpu 上预先算好

fs：检查 over draw 现象是否严重。检查代码有无分支、大循环。检查某些 feature 能否降分辨率实现

    注：这里感觉没回答好，vs 开销大也可能是远处高模几何体太多，占像素面积不大但顶点多


Q：知道 CSM 吗？CSM 存在什么问题？如何优化 CSM 的性能？

自己项目实现过。通过渲染多张深度图实现

draw call 开销大，显存带宽开销大

阴影相机做视锥剔除。或者 csm 不开太远，远处阴影靠 SDF 或干脆不绘制阴影


Q：RayMarch 和 RayTracing 有何区别？有哪些加速 RayMarch 的策略？

RayMarch 需要老老实实一步一步步进，收集沿途的信息，而 RayTracing 只关心射线和场景的交点，不关心步进的过程，因此可以用一些策略加速步进

常规：降分辨率 + 随机步长 + temporal

Hiz：在深度图的 mipmap 串上面进行步进

追问：还有呢？

有符号距离场（SDF）


Q：使用过 Git 吗？如何排查 200 个 commit 中的 bug ？

暴力法：一个一个 commit 去运行，检查

二分法：如果某个 commit 发生了 bug 那它之后的 commit 都是有问题的，就不用检查了。每次排除一半


Q：在校园没什么机会接触到 git 和多人开发，如何培养适应使用 git 的能力？

自己写代码的时候，加新功能都开一个新分支，调试没问题了再 merge 回去


二面

Q：有详细了解原神的各个渲染 pass 吗？

这个问题比较开放，网上的分析文章看的不够多（很早之前看过但是忘了）答得不好。只大致按顺序答了下几个 pass

阴影 → 从近到远绘制不透明物体 → 从远到近绘制透明物体 → 后处理


Q：屏幕空间反射的原理是什么？步进过程能优化吗？在移动设备如何实现镜面反射？

单次反弹的光线追踪。利用深度图，通过比较采样深度和测试深度的大小来判断射线与场景求交。返回交点颜色作为反射的颜色

步进过程可以通过降分辨率、Hi-Z、SDF 等策略优化

在移动设备 tracing 开销过大，可以使用反射探针（静态场景）或者加一个 camera 渲染到 RT 的策略（比如镜子）


Q：知道哪些常见渲染路径？它们有什么差异？

前向、延迟

前向渲染逐物体计算光照，可能有 over draw；延迟渲染逐屏幕像素计算，开销和场景复杂度无关

前向渲染不同物体可以使用不同的光照；而延迟渲染不区分物体，所有的像素都用同一套光照

前向渲染多光源需要重复多次绘制（多个 pass）渲染；延迟渲染一次性遍历所有光源并在一个 pass 中计算


Q：Deferred 性能上最大的缺点？有没有什么优化的方法？

带宽、通过压缩 gbuffer 大小来优化

这里踩雷了，一面面试官提到 metal 有移动端实现优化 gbuffer 的方式，回去没详细了解，这里也没答上来


Q：知道哪些纹理贴图的压缩算法？

没有了解（再次踩雷

    注：常见的有 DXTC、ETC、ASTC


Q：如何改进前向渲染？具体怎么实现？

forward 改 forward+，对屏幕 XY 方向分 tile，对每个 tile 进行光源剔除，保留影响当前 tile 的光源，然后计算光照


Q：你会选用 forward+ 还是 deferred 管线？为什么？

开放问题，我答了 forward+，这种题理由充分答哪边都行

原因：对多光源场景有明显优化、支持 MSAA、透明物体绘制方便


Q：一面中有提到虚拟纹理，下去有深入了解吗？说说看

类似虚拟内存，将大纹理（比如地形纹理）分成一块一块的页（page），按需调入


Q：知道 Single Pass 吗？

不知道（开摆

这个好像是 Unity VR 的选项？一般 VR 是渲染左右眼共两次，而 Single Pass 一次性将画面渲染到两倍宽度的 RT 上面


Q：移动端、PC 端 GPU 在显存、架构上有何不同？为什么移动端采用这种解决方案？

移动端不分内存显存，但是 cpu 和 gpu 无法交叉访存。渲染方面使用 tile base，每次渲染一小块屏幕区域。依次将每个 tile 的数据调入小容量、低功耗的高速存储器（Tile Memory）进行光栅化、着色等计算


Q：说一说 GPU Driven 能实现哪些功能？具体怎么实现的？

遮挡剔除，先生成低分辨率深度图，然后将物体 bounding box 和深度图做对比，如果被挡住则不用绘制。

这里当时回答的时候没有说清楚，低分辨率深度图的获取主要分为两个流派，一种是 cpu 做软光栅化，另一种是回读上一帧的深度图


Q：compute shader 剔除结果需要回读到 cpu 吗？能直接绘制吗？

可以不直接回读，在 GPU 直接执行绘制命令

需要图形 API 达到一定版本才支持，比如 DX12 的 ExecuteIndirect


Q：compute shader 使用时会有什么问题，需要注意什么？

执行某些算法时 cpu 需要向 gpu 提交大量数据，内存 -显存的数据迁移造成开销

    注：这里没答好，感觉面试官想问线程同步、硬件特性、wrap 优化性能这方面的。因为每个 GPU SIMD 的特性，每个 wrap 内所有线程执行一样的指令，所以难以处理分支指令。一般是两边都走然后各取结果所以效率低


Q：有用 compute shader 实现过什么功能？

写过 Cluster Lighting，每个 cluster 分配一个线程去做光源剔除


Q：了解哪些图形 API ？有写过 DX 吗？

OpenGL、DX、Metal、Vulkan

只写过 OpenGL，手搓过延迟渲染和光线追踪


Q：自己项目做了哪些优化？

Bloom 高斯模糊分横竖两个 pass，dowm sample + up sample 用硬件 Bilinear 做快速滤波

体积云用降分辨率 tracing 然后 up sample 到屏幕上


Q：降分辨率会有什么问题？你怎么解决？

体积云，低分辨率的 RT 直接 up sample 回去，会模糊，在深度变化较大的边缘会有 Artifact

当时没答出来怎么解决，直接说反正体积光体积云是模糊的，用户看不出来就苟住了（雷区蹦迪

    注：实际上应该把 RT 的深度一起存了，up sample 的时候顺便看看屏幕深度和 RT 深度是否相差过大，如果是的话就舍弃


Q：int 几字节？不同 CPU 架构下大小会变吗？长整型呢？

4B、在 32 位下 long 也是 4B，而 64 位下 long 变为 8B


Q：超大型整数，数据结构如何设计？相加溢出怎么处理？

利用 bitmap 存储每一个 bit 的信息

相加溢出可以和硬件 ALU 一样做上、下溢并设置 overflow flag

追问：如果需要保证结果正确呢？

可以用类似 vector 的变长线性容器来存储 bitmap，在溢出的时候适当延长 bitmap 的位数


Q：链表倒数第 k 个数

双指针，p1 先走 k 步然后 p1 p2 一起走，p1 走到头 p2 指向的就是倒数第 k 个节点


Q：蓝眼睛的人

这题是益智题，当时没做出来。参考 逻辑题：蓝眼睛的人请上飞机


三面

问题比较开放，感觉是考察对图形渲染算法的个人理解... 还有一些生活上的问题，比如为什么选择工作而不是读研等等就不列举了。下面是几个比较有意思的技术问题


Q：读过哪些图形 & 渲染方面的书籍？

主要以看互联网博客为主。理论方面看过 GAMES 101 和 202（没看完，强答了属于是），图形 API 的话看过 Learn OpenGL 并跟着动手搓过延迟管线，实现过 PBR。光线追踪的话在代码方面看过老外基于 shadertoy 写的 Casual path tracing，Unity 的话基本是以谷歌和文档为主，要用啥功能就去搜对应的 API 或者去 GitHub 上面看看如何实现

    注：这里答的很烂，其实自己看过不少资料，理论的话比如 RTR4、PBRT、RayTracing in one week 书籍都没说上来
    代码方面，写低差异序列的时候偷过 blender 的代码，写环境贴图重要性采样的时候偷过某国外大学的 homework guide，写 BRDF 的时候偷过迪士尼的论文公式...
    临场太慌了脑子转不过来，这些都没说出来。我这狗嘴吐不出象牙，给面试官的感觉就是我是代码小偷只会偷


Q：谈谈开放世界游戏中的天气变化，比如下雨天在渲染上需要如何处理？

有点偏美术的开放题，这题答得不是很好，仅供参考

光照：来自太阳的平行光（场景主光）减弱或者消失，依赖场景光源（比如路灯）进行照明

云：云层应该变得稠密，通过修改采样噪声图的参数实现

植被：植被的晃动程度应该增加

雾：雾的浓度增加，如果是 cluster lighting 管线下，frustum voxel 中有光源信息的话也可以做光源体积雾


Q：你自己也实现过 Cluster Lighting，说说这个策略有什么缺点，存在什么问题？

需要 cpu 提交大量数据到 gpu，造成开销

这里只答了一个点，当时蒙了。因为一般是说优点，突然问个缺点没反应过来。仔细想了想面试官可能想问移动端 compute shader 的兼容性、跳跃存取 compute buffer 数据带来的 cache 缺失开销、warp 内走的分支不同导致开销等问题


Q：怎么理解光线追踪中的重要性采样？

好钢用在刀刃上。对亮度贡献大的方向（比如环境贴图中的亮处、BRDF 大的方向）多分配光线，使用少量采样就可以达到不错的效果


Q：知道 HDR 吗？谈谈 HDR 和 Bloom 的关系

普通像素的范围在 0~255，而 HDR 能够模拟物理世界中正确的光照，比如环境贴图中亮度上万的像素。使用 HDR 在物理上能够得出正确的颜色，但是屏幕显示不了那么亮，需要做一个色调映射再输出。

如果对 HDR 的 RT 做 Bloom，单个超亮的像素也能扩出大范围的光晕，比如《无主之地3》中高亮的天线：


Q：实现过 Bloom 吗？是怎么实现的？为何在 Bloom 时候要采样多级 mipmap？不这么做会有什么结果？

两种方法：用横竖两次高斯模糊、或者 down sample 出一串 mip 然后再 up sample 回屏幕

如果采样单级 mip，因为硬件 Bilinear 滤波是 2x2 的盒子，最终扩出的 bloom 结果会是方块形状的，很丑。叠加多级 mip 的结果，方块感没那么强

    注：这里又没答好，用低分辨率的 mip 还有一个好处就是 bloom 扩散的范围会非常大。而高斯模糊的效果要想做到与前者同样大的扩散范围，需要更大的 filter size 也带来了更高的开销


渲染管线？
延迟渲染？
齐次坐标？
透视除法？
编译过程？
动静链接？
三握信号量变换？

1. 单一职责原则SRP(Single Responsibility Principle)
每一个类应该专注于一件事情，对外只提供一种功能，即每个类只有一种功能，否则一个类可以实现多种功能但是效率低下。用比喻来讲就是一个人专注去做一件事效率就会很高，做了很多事就会很累效率降低。
2. 开放封闭原则OCP(Open－Close Principle)
面向扩展开放，面向修改关闭，即增加功能是通过增加代码，而不是修改代码
比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，
那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，
这要求在设计之初，就应当将各模块分开，将公共部分抽象出来。
3. 里氏转换原则(the Liskov Substitution Principle LSP)
在任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制（多态），语言级别实现面向对象功能。
即：子类应当可以替换父类并出现在父类能够出现的任何地方。
比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。
4. 依赖倒转原则(the Dependency Inversion Principle DIP)
实现尽量依赖抽象类，不依赖具体实现，依赖于抽象类提供的接口，也就是针对接口编程
具体依赖抽象，上层依赖下层。
假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。
5. 接口隔离原则(the Interface Segregation Principle ISP)
模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
本原则是单一职责原则用于接口设计的自然结果。一个接口应该保证，实现该接口的实例对象可以只呈现为单一的角色；这样，当某个客户程序的要求发生变化，而迫使接口发生改变时，影响到其他客户程序的可能生性小。
6. 组合/聚合原则
原则就是在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。
要尽量使用合成/聚合达到复用，而不是继承关系达到复用的目的，如果使用继承，会导致父类的任何变换都可能影响到子类的行为。
    继承复用：实现简单，易于扩展。破坏系统的封装性，从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）
    组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用 ）
组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；
7. “迪米特”法则
又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用，一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性
① 在类的划分上，应该创建有弱耦合的类；
② 在类的结构设计上，每一个类都应当尽量降低成员的访问权限；
③ 在类的设计上，只要有可能，一个类应当设计成不变类；
④ 在对其他类的引用上，一个对象对其它对象的引用应当降到最低；
⑤ 尽量降低类的访问权限；
⑥ 谨慎使用序列化功能；
⑦ 不要暴露类成员，而应该提供相应的访问器(属性)。