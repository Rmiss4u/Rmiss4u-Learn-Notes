cerr 错误警告输出
clog 运行一般性信息

024 八进制
0x24 十六进制
![](../../assets/2022-05-30-15-00-24.png)

顶层const 指针本身是个常量        常指针
底层const 指针所指的对象是一个常量 指针常量
![](../../assets/2022-05-31-13-39-45.png)
![](../../assets/2022-05-31-13-39-51.png)
![](../../assets/2022-05-31-13-40-18.png)

constexpr 常量表达式(向下对齐)

typedef double *p;      //p和double*等价
using SI=Sales_item;    //同义词 别名声明
注：
![](../../assets/2022-05-31-14-20-55.png)

auto语句中所有变量初始基本数据类型必须一致

decltype 选择并返回操作数的数据类型 另，双括号代表引用
int a;
decltype(a) sun=a;

预处理器->头文件保护符
//头文件 sales_data.h -> SALES_DATA_H 变为已定义
#ifndef SALES_DATA_H
#define SALES_DATA_H
#endif
-> #include "sales_data.h"
以及 #pragma once
//避免重复包含的发生

using std::cin;
std::cin -> cin

string
![](../../assets/2022-05-31-16-13-33.png)
getlint(cin,line);

string.size() 返回 size_type类型 无符号整型数
例 string.size()<n -> 几乎为true (带符号数和无符号数之间出现的问题)

![](../../assets/2022-05-31-16-27-11.png)
字符串字面值与string类型是不同的

cctype头文件函数 (继承自name.h的c头文件)
![](../../assets/2022-05-31-16-29-24.png)

迭代器类型iterator const_iterator

指针相减是ptrdiff_t 标准库类型 (带符号类型)

cstring库函数
![](../../assets/2022-06-01-15-35-52.png)

![](../../assets/2022-06-01-15-44-27.png)
数组指针 指针数组
![](../../assets/2022-06-01-15-50-12.png)

static_cast
//进行强制类型转换以便执行浮点数除法
double slope=static_cast<double>(j) / i;
![](../../assets/2022-06-01-18-06-37.png)

dynamic_cast
//将基类的指针或引用安全地转换成派生类的指针或引用
![](../../assets/2022-06-12-16-59-13.png)
![](../../assets/2022-06-12-16-59-20.png)
支持运行时类型识别 19.2节讲述

const_cast
![](../../assets/2022-06-01-18-06-58.png)
![](../../assets/2022-06-01-18-07-09.png)

reinterpret_cast(非常危险)
![](../../assets/2022-06-01-18-20-04.png)

![](../../assets/2022-06-01-18-54-51.png)

goto end;
1;
end:2;

try{
}catch(1){
}catch(1){
}

throw runtime_error("data must refer to same ISBN");

![](../../assets/2022-06-02-22-18-27.png)

引用和指针形参函数都可以改变原有的值
试用引用避免拷贝
若无须改变引用形参值 最好声明为常量引用 (1.对调用者易读 2.对函数调用时常变量参数编译会出错)

![](../../assets/2022-06-03-14-01-51.png)

![](../../assets/2022-06-03-15-06-00.png)
void print(int matrix[][10],int rowSize){}//等价

![](../../assets/2022-06-03-16-17-05.png)
//内为常值类型

void fun(...);//省略符形参

![](../../assets/2022-06-03-16-25-21.png)

不要返回局部对象的引用或指针

引用返回左值
char &get_val(string &str,string::size_type ix)
{
    return str[ix];
}
int main()
{
    string s("a value");
    cout<<s<<endl;
    get_val(s,0)='A';//调用左值 s[0]变为大写
    cout<<s<<endl;
    return 0;
}

![](../../assets/2022-06-04-13-15-25.png)

![](../../assets/2022-06-04-13-20-18.png)
![](../../assets/2022-06-04-13-20-24.png)

尾置返回类型 auto func(int i)->int(*)[10];
//返回指向有10个整数数组的指针

decltype
![](../../assets/2022-06-04-19-43-00.png)

overload 函数名字相同 形参列表不同 (只有返回类型不同不行)

![](../../assets/2022-06-04-20-26-39.png)

![](../../assets/2022-06-04-20-40-36.png)
![](../../assets/2022-06-04-20-40-21.png)

内联函数可以避免函数调用开销 inline

constexpr函数不一定返回常量表达式

assert预处理宏 假止真续

函数指针  以指针替换函数名
bool (*pf)(const string &,const string &);
//括号必不可少 且返回类型要匹配
![](../../assets/2022-06-04-21-36-59.png)

![](../../assets/2022-06-04-21-42-40.png)
![](../../assets/2022-06-04-21-43-56.png)

返回指向函数的指针
using F=int(int*,int);
F *f1(int);
or
using FF=int(*)(int*,int);
FF f1(int);
or
int (*f1(int))(int*,int);
or
auto f1(int)->int(*)(int*,int);

![](../../assets/2022-06-04-21-57-36.png)
io类型不能被拷贝因而以引用传递

![](../../assets/2022-06-04-21-59-36.png)
![](../../assets/2022-06-04-21-59-41.png)

某些类不能依赖于合成的默认构造函数
成员全部被赋予类内初始值才适合于使用合成的默认构造函数

class/struct 唯一区别即默认访问权限

friend 友元声明只能出现在类定义内部
最好在友元声明之外对函数进行一次声明

类型成员
![](../../assets/2022-06-05-14-35-18.png)
![](../../assets/2022-06-05-14-35-56.png)

![](../../assets/2022-06-05-14-38-21.png)

const成员函数以引用返回*this则返回常量引用类型

![](../../assets/2022-06-05-14-59-12.png)
![](../../assets/2022-06-05-14-59-39.png)

::name 隐藏外层作用域访问运算符

![](../../assets/2022-06-06-12-50-01.png)

编译器只会自动执行一步类型转换

explicit 阻止构造函数隐式转换
构造函数只能用于直接初始化不能使用explicit
![](../../assets/2022-06-06-13-08-02.png)

聚合类
![](../../assets/2022-06-06-13-30-05.png)
变量要按顺序初始化
![](../../assets/2022-06-06-13-33-27.png)
![](../../assets/2022-06-06-13-34-49.png)

外部定义静态变量时不能重复static关键字(只出现在类内部声明)不是由类的构造函数初始化

![](../../assets/2022-06-06-13-44-49.png)

![](../../assets/2022-06-06-13-56-49.png)
![](../../assets/2022-06-06-13-57-02.png)
![](../../assets/2022-06-06-14-09-13.png)

当fstream对象被销毁时,close会自动被调用

![](../../assets/2022-06-06-14-12-19.png)
![](../../assets/2022-06-06-14-13-26.png)

![](../../assets/2022-06-06-14-33-05.png)

![](../../assets/2022-06-06-14-36-27.png)
![](../../assets/2022-06-06-14-36-39.png)
![](../../assets/2022-06-06-14-36-53.png)

![](../../assets/2022-06-06-15-21-13.png)

emplace_front/emplace/emplace_back操作构造而非拷贝元素
在容器管理内存空间中直接构造元素

![](../../assets/2022-06-06-15-46-32.png)
![](../../assets/2022-06-06-15-46-55.png)
![](../../assets/2022-06-06-15-48-22.png)
![](../../assets/2022-06-06-15-48-59.png)
![](../../assets/2022-06-06-15-57-30.png)
![](../../assets/2022-06-06-15-59-27.png)
![](../../assets/2022-06-06-16-02-15.png)
![](../../assets/2022-06-06-16-04-21.png)
![](../../assets/2022-06-06-16-04-51.png)
![](../../assets/2022-06-06-16-04-40.png)
![](../../assets/2022-06-06-16-06-03.png)
![](../../assets/2022-06-06-16-06-12.png)
![](../../assets/2022-06-06-16-07-54.png)
![](../../assets/2022-06-06-16-08-50.png)
![](../../assets/2022-06-06-16-09-16.png)
![](../../assets/2022-06-06-16-10-51.png)
![](../../assets/2022-06-06-16-11-20.png)
![](../../assets/2022-06-06-16-11-38.png)

lambda
值捕捉
![](../../assets/2022-06-06-21-02-17.png)
引用捕获
![](../../assets/2022-06-06-21-02-30.png)
![](../../assets/2022-06-06-21-54-40.png)
隐式捕获
![](../../assets/2022-06-06-21-55-30.png)

![](../../assets/2022-06-06-21-55-03.png)

可变lambda
![](../../assets/2022-06-06-21-57-54.png)

bind函数 functional头文件 预先把指定可调用实体的某些参数绑定到已有的变量
![](../../assets/2022-06-06-22-12-05.png)
![](../../assets/2022-06-06-22-11-36.png)

迭代器
![](../../assets/2022-06-06-22-13-10.png)
istream_iterator流迭代器
![](../../assets/2022-06-06-22-20-25.png)
accumulate函数调用算总和
允许使用懒惰求值
ostream_iterator
![](../../assets/2022-06-06-22-21-49.png)
反向迭代器
![](../../assets/2022-06-06-22-22-38.png)
![](../../assets/2022-06-06-22-23-31.png)

泛型算法解构
![](../../assets/2022-06-06-22-23-52.png)
![](../../assets/2022-06-06-22-24-57.png)

![](../../assets/2022-06-06-22-36-13.png)
![](../../assets/2022-06-06-22-36-31.png)
![](../../assets/2022-06-06-22-36-38.png)

![](../../assets/2022-06-06-22-39-33.png)
![](../../assets/2022-06-06-22-39-44.png)

![](../../assets/2022-06-06-22-39-54.png)

关联容器
![](../../assets/2022-06-06-22-46-30.png)

pair类型 头文件utility
![](../../assets/2022-06-06-23-06-46.png)
![](../../assets/2022-06-06-23-11-36.png)

![](../../assets/2022-06-06-23-16-06.png)

map关键字不可改
set可读不可修改
关键字升序
![](../../assets/2022-06-06-23-25-51.png)
![](../../assets/2022-06-06-23-25-57.png)
![](../../assets/2022-06-06-23-26-05.png)

![](../../assets/2022-06-07-13-54-27.png)
![](../../assets/2022-06-07-13-56-25.png)
![](../../assets/2022-06-07-13-56-56.png)
![](../../assets/2022-06-07-13-57-15.png)

无序关联容器(hash哈希函数关键字类型==运算符)
![](../../assets/2022-06-07-14-26-53.png)

动态内存 头文件memory
shared_ptr允许多个指针指向同一个对象
unique_ptr独占所指向对象
weak_ptr伴随类弱引用 指向share_ptr所管理的对象
shared_pt<string> p1; //可以指向string
![](../../assets/2022-06-07-14-33-10.png)
![](../../assets/2022-06-07-14-33-22.png)
make_shared函数 最安全的分配和使用动态内存的方法调用函数(动态内存中非分配一个对象并初始化,返回指向此对象的shared_ptr)
shared_ptr<string> p3=make_shared<string>(10,'9');

shared_ptr会记录有多少个其他shared_ptr指向相同的对象(引用计数)
![](../../assets/2022-06-07-14-40-15.png)
![](../../assets/2022-06-07-15-16-27.png)
![](../../assets/2022-06-07-15-20-00.png)
![](../../assets/2022-06-07-15-21-37.png)
![](../../assets/2022-06-07-15-22-11.png)

四哦那个了动态内存期的资源的类
1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的精准类型
3.程序需要在多个对象间共享数据
动态内存常见使用原因是允许多个对象共享相同的状态
除非是用智能指针管理内存 否则不要分配动态内存

内存耗尽 定位new
![](../../assets/2022-06-07-15-54-43.png)

![](../../assets/2022-06-07-16-12-47.png)
![](../../assets/2022-06-07-16-13-46.png)
![](../../assets/2022-06-07-16-14-14.png)
![](../../assets/2022-06-07-16-14-46.png)

delte之后指针变成悬空指针(指向一块曾经保存数据对象但已经无效的内存的指针)且其提供的保护是有限的(多个指针指向相同的内存,仅delete的指针生效,其他无效且其他指针的对象被清空了)
->
shared_ptr和new结合使用
shared_ptr<int> p2(new int(42));
shared_ptr<int> p1=new int(1024);//错误 必须使用直接初始化形式
![](../../assets/2022-06-07-16-51-34.png)
![](../../assets/2022-06-07-16-53-13.png)
![](../../assets/2022-06-07-16-53-58.png)

不要混合使用普通指针和智能指针
拷贝会增加引用次数
因此使用内置指针来访问一个智能指针所负责的对象是很危险的,因为无法知道对象何时被销毁

不要使用get初始化另一个智能指针或为智能指针赋值
使用get返回指针的代码不能delete此指针
![](../../assets/2022-06-07-17-23-29.png)
![](../../assets/2022-06-07-17-24-12.png)

![](../../assets/2022-06-07-17-33-37.png)
shared_ptr第二个参数即是调用删除器的函数指针
![](../../assets/2022-06-07-18-13-09.png)

unique_ptr某时刻只能有指向一个给定对象
![](../../assets/2022-06-07-18-15-07.png)
![](../../assets/2022-06-07-18-35-46.png)
![](../../assets/2022-06-07-18-36-33.png)

weak_ptr不控制所指向对象生存期的智能指针 弱共享对象
![](../../assets/2022-06-07-18-39-11.png)
lock函数检查weak_ptr指向对象是否存在
share_ptr<int> np=wp.lock();//np不为空则条件成立

暂时:不要再类内的代码中分配动态内存

![](../../assets/2022-06-07-18-56-12.png)
![](../../assets/2022-06-07-18-55-56.png)

智能指针和动态数组
![](../../assets/2022-06-07-18-57-38.png)
![](../../assets/2022-06-07-18-58-05.png)
![](../../assets/2022-06-07-18-58-52.png)

allocator类 头文件memory
![](../../assets/2022-06-07-19-04-05.png)
分配的内存是未构造的
![](../../assets/2022-06-07-23-04-33.png)
![](../../assets/2022-06-07-23-04-38.png)
![](../../assets/2022-06-07-23-05-02.png)
![](../../assets/2022-06-07-23-05-14.png)
![](../../assets/2022-06-07-23-14-09.png)

拷贝控制
explicit避免隐式拷贝 因而拷贝构造函数无法使用
![](../../assets/2022-06-09-12-41-17.png)

![](../../assets/2022-06-09-12-45-09.png)
![](../../assets/2022-06-09-12-46-03.png)

三五法则
![](../../assets/2022-06-09-13-17-30.png)
需要构造函数的类也需要拷贝和赋值操作
![](../../assets/2022-06-09-13-20-37.png)
需要拷贝操作的类也需要赋值操作,反之亦然

=default显式要求编译器生成合成版本(不希望定义这些成员)
![](../../assets/2022-06-09-13-22-05.png)

阻止拷贝
![](../../assets/2022-06-09-13-22-25.png)
析构函数不能是删除的成员
![](../../assets/2022-06-09-13-24-00.png)
合成拷贝控制成员可能是删除的
![](../../assets/2022-06-09-13-25-46.png)
![](../../assets/2022-06-09-13-25-58.png)
![](../../assets/2022-06-09-13-26-14.png)
private拷贝控制
![](../../assets/2022-06-09-13-27-17.png)

![](../../assets/2022-06-09-13-36-45.png)
![](../../assets/2022-06-09-13-37-09.png)

![](../../assets/2022-06-09-15-00-06.png)

![](../../assets/2022-06-09-15-18-04.png)
![](../../assets/2022-06-09-15-18-16.png)
![](../../assets/2022-06-09-15-18-58.png)
![](../../assets/2022-06-09-15-19-38.png)

StrVec
![](../../assets/2022-06-09-15-21-08.png)
construct
![](../../assets/2022-06-09-15-21-40.png)
![](../../assets/2022-06-09-15-22-10.png)
![](../../assets/2022-06-09-15-22-24.png)
![](../../assets/2022-06-09-15-22-55.png)
拷贝控制成员
重新分配内存过程中移动而不是拷贝元素
移动构造函数和std::move
realocate成员

对象移动相对拷贝提升了性能
![](../../assets/2022-06-09-15-25-55.png)

右值引用 只能绑定到一个将要销毁的对象
![](../../assets/2022-06-09-15-55-14.png)
左值持久 右值短暂
![](../../assets/2022-06-09-15-55-24.png)
![](../../assets/2022-06-09-15-54-56.png)
move函数绑定左值到右值引用
![](../../assets/2022-06-09-15-56-06.png)
//注意std::
![](../../assets/2022-06-09-16-01-51.png)

移动构造函数和移动赋值运算符 noexcept
![](../../assets/2022-06-09-16-02-40.png)
![](../../assets/2022-06-09-16-05-41.png)
![](../../assets/2022-06-09-16-06-02.png)

移动赋值运算符
![](../../assets/2022-06-09-16-07-21.png)
![](../../assets/2022-06-09-16-07-28.png)

移后源对象必须可析构
![](../../assets/2022-06-09-16-11-23.png)

合成移动操作
![](../../assets/2022-06-09-16-12-32.png)
![](../../assets/2022-06-09-16-25-47.png)
![](../../assets/2022-06-09-16-27-01.png)

移动右值 拷贝左值
![](../../assets/2022-06-09-17-39-44.png)

没有移动构造函数 右值也被拷贝
![](../../assets/2022-06-09-17-42-07.png)
![](../../assets/2022-06-09-17-41-55.png)

拷贝 交换赋值运算符 移动操作
![](../../assets/2022-06-09-17-44-33.png)
![](../../assets/2022-06-09-17-51-11.png)
![](../../assets/2022-06-09-17-51-31.png)

massage类移动操作
![](../../assets/2022-06-09-17-53-22.png)
![](../../assets/2022-06-09-17-57-13.png)
![](../../assets/2022-06-09-17-57-22.png)

移动迭代器(通过改变给定迭代器的解引用运算符的行为来适配迭代器)
![](../../assets/2022-06-09-18-01-56.png)
![](../../assets/2022-06-09-18-02-04.png)
![](../../assets/2022-06-09-18-02-16.png)

右值引用和成员函数
![](../../assets/2022-06-09-18-03-43.png)
![](../../assets/2022-06-09-18-08-59.png)
![](../../assets/2022-06-09-18-09-16.png)

左右值引用成员函数
![](../../assets/2022-06-09-18-19-30.png)
![](../../assets/2022-06-09-18-20-01.png)
![](../../assets/2022-06-09-18-20-36.png)

重载和引用函数
![](../../assets/2022-06-09-18-21-04.png)
![](../../assets/2022-06-09-18-22-54.png)
![](../../assets/2022-06-09-18-23-33.png)
![](../../assets/2022-06-09-18-24-46.png)

重载运算与类型转换
![](../../assets/2022-06-09-18-52-31.png)
![](../../assets/2022-06-09-18-55-47.png)
![](../../assets/2022-06-09-18-57-22.png)
使用与内置类型一致的含义
![](../../assets/2022-06-09-18-58-16.png)
![](../../assets/2022-06-09-18-58-41.png)

赋值 复合赋值运算符
选择作为成员或者非成员
![](../../assets/2022-06-09-19-00-18.png)

输入输出运算符
<<重载
![](../../assets/2022-06-09-20-26-16.png)
![](../../assets/2022-06-09-20-29-55.png)
输入输出运算符必须是非成员函数
>>重载
![](../../assets/2022-06-09-21-00-09.png)
![](../../assets/2022-06-09-21-00-52.png)
![](../../assets/2022-06-09-21-02-42.png)
![](../../assets/2022-06-09-21-02-59.png)

+
![](../../assets/2022-06-09-21-06-46.png)
![](../../assets/2022-06-09-21-07-10.png)

== !=
![](../../assets/2022-06-09-21-08-45.png)
![](../../assets/2022-06-09-21-08-54.png)
![](../../assets/2022-06-09-21-09-06.png)
![](../../assets/2022-06-09-22-21-52.png)

赋值
![](../../assets/2022-06-09-22-22-14.png)
![](../../assets/2022-06-09-22-22-20.png)
![](../../assets/2022-06-09-22-22-34.png)

复合
![](../../assets/2022-06-09-22-22-48.png)

下标
![](../../assets/2022-06-09-22-23-01.png)
![](../../assets/2022-06-09-22-23-06.png)
![](../../assets/2022-06-09-22-23-17.png)

递增 递减
![](../../assets/2022-06-09-22-23-30.png)
![](../../assets/2022-06-09-22-23-35.png)
![](../../assets/2022-06-09-22-23-43.png)
![](../../assets/2022-06-09-22-23-50.png)

区分前置 后置运算符 ++ --
![](../../assets/2022-06-09-22-26-17.png)
![](../../assets/2022-06-09-22-26-26.png)

显式的调用后置运算符
![](../../assets/2022-06-09-22-26-53.png)

成员访问运算符 ->
![](../../assets/2022-06-09-22-39-18.png)
![](../../assets/2022-06-09-22-39-32.png)

对箭头运算符返回值的限定
![](../../assets/2022-06-10-23-44-55.png)
![](../../assets/2022-06-10-23-45-00.png)

![](../../assets/2022-06-11-14-09-54.png)
![](../../assets/2022-06-11-14-11-25.png)

lambda函数对象
![](../../assets/2022-06-11-14-13-34.png)
![](../../assets/2022-06-11-14-14-04.png)

标准库定义的函数对象
![](../../assets/2022-06-11-14-39-22.png)
![](../../assets/2022-06-11-14-41-40.png)

不同类型可能具有相同的调用形式
![](../../assets/2022-06-11-14-44-45.png)
![](../../assets/2022-06-11-14-45-06.png)
![](../../assets/2022-06-11-14-47-28.png)
![](../../assets/2022-06-11-14-47-39.png)
![](../../assets/2022-06-11-14-48-05.png)
![](../../assets/2022-06-11-14-48-10.png)

重载函数与function
![](../../assets/2022-06-11-14-49-13.png)
![](../../assets/2022-06-11-14-49-52.png)
![](../../assets/2022-06-11-14-50-23.png)

类型转换运算符可能会产生意外结果

显式类型转换运算符
![](../../assets/2022-06-11-14-51-36.png)
![](../../assets/2022-06-11-14-52-06.png)

避免二义性类型转换
![](../../assets/2022-06-11-14-52-27.png)
二义性与转换目标为内置类型的多重类型转换
![](../../assets/2022-06-11-14-53-18.png)
![](../../assets/2022-06-11-14-53-27.png)
![](../../assets/2022-06-11-14-53-45.png)

重载函数与用户定义的类型转换
![](../../assets/2022-06-11-14-54-56.png)

函数匹配与重载运算符
![](../../assets/2022-06-11-14-55-21.png)
![](../../assets/2022-06-11-14-55-38.png)

面向对象程序设计
动态绑定
![](../../assets/2022-06-11-15-21-54.png)
![](../../assets/2022-06-11-15-28-09.png)

定义基类
![](../../assets/2022-06-11-15-28-40.png)
![](../../assets/2022-06-11-15-28-55.png)
派生
![](../../assets/2022-06-11-15-36-58.png)
![](../../assets/2022-06-11-15-38-23.png)
派生类构造函数
![](../../assets/2022-06-11-15-38-39.png)
![](../../assets/2022-06-11-15-38-48.png)
![](../../assets/2022-06-11-15-38-57.png)
派生类使用基类成员
![](../../assets/2022-06-11-15-39-16.png)
![](../../assets/2022-06-11-15-39-30.png)
继承与静态成员
![](../../assets/2022-06-11-15-39-54.png)
派生类声明
![](../../assets/2022-06-11-15-43-01.png)
防止继承发生的方法
![](../../assets/2022-06-11-15-46-38.png)

![](../../assets/2022-06-11-15-47-20.png)
![](../../assets/2022-06-11-15-50-32.png)

不存在从基类向派生类的隐式转换
![](../../assets/2022-06-11-15-52-53.png)
![](../../assets/2022-06-11-15-52-59.png)
在对象之间不存在类型转换
![](../../assets/2022-06-11-15-54-13.png)
![](../../assets/2022-06-11-16-00-26.png)
![](../../assets/2022-06-11-16-00-32.png)
![](../../assets/2022-06-11-16-01-30.png)

虚函数
对虚函数的调用可能在运行时才被解析
![](../../assets/2022-06-11-16-09-48.png)
![](../../assets/2022-06-11-16-10-08.png)

final override说明
override标记需要父类virtual定义
![](../../assets/2022-06-11-16-13-37.png)
final不允许被继承
![](../../assets/2022-06-11-16-14-39.png)
![](../../assets/2022-06-11-16-15-14.png)
![](../../assets/2022-06-11-16-15-23.png)
![](../../assets/2022-06-11-16-15-37.png)

抽象基类
![](../../assets/2022-06-11-17-42-03.png)
![](../../assets/2022-06-11-17-42-13.png)
![](../../assets/2022-06-11-17-42-21.png)

派生类构造函数只初始化它的直接基类
![](../../assets/2022-06-11-17-43-29.png)
![](../../assets/2022-06-11-17-43-35.png)
![](../../assets/2022-06-11-17-43-46.png)

![](../../assets/2022-06-11-17-44-09.png)
![](../../assets/2022-06-11-17-44-17.png)
![](../../assets/2022-06-11-17-44-22.png)

友元关系不能继承 派生类的友元不能随意访问基类成员
![](../../assets/2022-06-11-17-44-58.png)
![](../../assets/2022-06-11-17-45-18.png)
![](../../assets/2022-06-11-17-45-49.png)

继承中的类作用域
![](../../assets/2022-06-11-17-46-23.png)

![](../../assets/2022-06-11-17-46-56.png)
![](../../assets/2022-06-11-17-47-00.png)
![](../../assets/2022-06-11-17-47-06.png)

名字冲突与继承
![](../../assets/2022-06-11-17-47-27.png)
![](../../assets/2022-06-11-17-47-34.png)

通过作用域运算来使用隐藏成员
![](../../assets/2022-06-11-17-48-59.png)
![](../../assets/2022-06-11-17-49-07.png)
![](../../assets/2022-06-11-17-49-15.png)

名字查找先于类型检查
![](../../assets/2022-06-11-17-54-03.png)

虚函数和作用域
![](../../assets/2022-06-11-17-54-46.png)

通过基类调用隐藏的虚函数
![](../../assets/2022-06-11-17-58-33.png)
![](../../assets/2022-06-11-18-01-59.png)

构造函数与拷贝控制
虚析构函数
![](../../assets/2022-06-11-18-05-29.png)
![](../../assets/2022-06-11-18-05-49.png)
![](../../assets/2022-06-11-18-11-11.png)

虚析构函数将阻止合成移动操作

合成拷贝控制与继承
![](../../assets/2022-06-11-18-14-58.png)

派生类中删除的拷贝控制与基类的关系
![](../../assets/2022-06-11-18-15-29.png)
![](../../assets/2022-06-11-18-15-37.png)

移动操作与继承
![](../../assets/2022-06-11-18-18-03.png)

派生类的拷贝控制成员
![](../../assets/2022-06-11-18-19-40.png)
定义派生类的拷贝或移动构造函数
![](../../assets/2022-06-11-18-20-01.png)
![](../../assets/2022-06-11-18-20-11.png)
![](../../assets/2022-06-11-18-20-20.png)

派生类赋值运算符
![](../../assets/2022-06-11-18-20-41.png)
![](../../assets/2022-06-11-18-20-47.png)

派生类析构函数
![](../../assets/2022-06-11-18-21-12.png)

在构造函数和析构函数中调用虚函数
![](../../assets/2022-06-11-18-21-36.png)

继承的构造函数
![](../../assets/2022-06-11-18-23-00.png)
![](../../assets/2022-06-11-18-23-24.png)

容器与继承
![](../../assets/2022-06-11-18-26-02.png)

容器中放智能指针
![](../../assets/2022-06-11-18-26-26.png)
……

隐藏指针
![](../../assets/2022-06-11-18-33-50.png)

![](../../assets/2022-06-11-18-34-30.png)
![](../../assets/2022-06-11-18-35-57.png)
……

模板与泛型编程
![](../../assets/2022-06-11-18-44-09.png)
![](../../assets/2022-06-11-18-44-24.png)
![](../../assets/2022-06-11-18-47-53.png)
![](../../assets/2022-06-11-18-48-15.png)

非类型模板参数
![](../../assets/2022-06-11-18-56-54.png)
![](../../assets/2022-06-11-18-57-05.png)

![](../../assets/2022-06-11-18-57-19.png)
![](../../assets/2022-06-11-18-57-28.png)
![](../../assets/2022-06-11-18-57-35.png)
![](../../assets/2022-06-11-18-57-54.png)
![](../../assets/2022-06-11-18-58-12.png)

定义类模板
![](../../assets/2022-06-11-19-09-33.png)
![](../../assets/2022-06-11-19-10-16.png)

![](../../assets/2022-06-12-11-55-50.png)
![](../../assets/2022-06-12-11-56-04.png)

模板类别名
![](../../assets/2022-06-12-11-56-48.png)

![](../../assets/2022-06-12-11-58-37.png)
![](../../assets/2022-06-12-11-58-49.png)
![](../../assets/2022-06-12-12-17-37.png)
![](../../assets/2022-06-12-12-17-45.png)

![](../../assets/2022-06-12-12-18-16.png)

![](../../assets/2022-06-12-12-23-40.png)

![](../../assets/2022-06-12-12-24-05.png)

![](../../assets/2022-06-12-12-24-17.png)
![](../../assets/2022-06-12-12-27-22.png)
![](../../assets/2022-06-12-12-27-30.png)

![](../../assets/2022-06-12-12-28-28.png)
![](../../assets/2022-06-12-12-28-38.png)
![](../../assets/2022-06-12-12-28-46.png)

重载与模板
![](../../assets/2022-06-12-12-29-09.png)
![](../../assets/2022-06-12-12-29-25.png)
![](../../assets/2022-06-12-12-29-35.png)
![](../../assets/2022-06-12-12-29-47.png)
![](../../assets/2022-06-12-12-30-43.png)
![](../../assets/2022-06-12-12-31-00.png)
![](../../assets/2022-06-12-12-35-35.png)

模板特例化
![](../../assets/2022-06-12-12-35-57.png)
![](../../assets/2022-06-12-12-36-05.png)
![](../../assets/2022-06-12-12-36-14.png)

![](../../assets/2022-06-12-12-36-23.png)

![](../../assets/2022-06-12-12-36-29.png)

高级主题 标准库特殊设施
![](../../assets/2022-06-12-12-37-33.png)
![](../../assets/2022-06-12-12-37-42.png)
![](../../assets/2022-06-12-12-37-57.png)

get访问tuple类 头文件tuple
![](../../assets/2022-06-12-12-41-55.png)
![](../../assets/2022-06-12-12-42-08.png)

bitset类 头文件bitset
![](../../assets/2022-06-12-12-52-07.png)
![](../../assets/2022-06-12-12-52-19.png)
![](../../assets/2022-06-12-13-01-37.png)
![](../../assets/2022-06-12-13-03-26.png)

正则
![](../../assets/2022-06-12-13-03-42.png)
![](../../assets/2022-06-12-13-04-05.png)
![](../../assets/2022-06-12-13-04-20.png)
![](../../assets/2022-06-12-13-04-28.png)
![](../../assets/2022-06-12-13-04-36.png)
![](../../assets/2022-06-12-13-04-47.png)
![](../../assets/2022-06-12-13-04-57.png)

匹配与regex迭代器类型
![](../../assets/2022-06-12-13-05-15.png)
![](../../assets/2022-06-12-13-05-31.png)
![](../../assets/2022-06-12-13-05-45.png)

子表达式
![](../../assets/2022-06-12-13-06-11.png)
![](../../assets/2022-06-12-13-06-19.png)

regex_replace
![](../../assets/2022-06-12-13-06-39.png)
![](../../assets/2022-06-12-13-06-52.png)

随机数
![](../../assets/2022-06-12-13-15-02.png)
![](../../assets/2022-06-12-16-31-01.png)
![](../../assets/2022-06-12-16-31-09.png)
![](../../assets/2022-06-12-16-31-23.png)
![](../../assets/2022-06-12-16-31-29.png)
![](../../assets/2022-06-12-16-31-37.png)
![](../../assets/2022-06-12-16-31-54.png)

IO库
![](../../assets/2022-06-12-16-32-07.png)
![](../../assets/2022-06-12-16-32-14.png)
![](../../assets/2022-06-12-16-32-24.png)
![](../../assets/2022-06-12-16-32-31.png)
![](../../assets/2022-06-12-16-32-41.png)
![](../../assets/2022-06-12-16-32-50.png)
![](../../assets/2022-06-12-16-32-58.png)
![](../../assets/2022-06-12-16-33-04.png)

![](../../assets/2022-06-12-16-33-16.png)
![](../../assets/2022-06-12-16-34-41.png)
![](../../assets/2022-06-12-16-34-53.png)
![](../../assets/2022-06-12-16-35-00.png)
![](../../assets/2022-06-12-16-35-13.png)

![](../../assets/2022-06-12-16-35-25.png)
![](../../assets/2022-06-12-16-35-32.png)

seek tell
![](../../assets/2022-06-12-16-36-01.png)
![](../../assets/2022-06-12-16-36-11.png)

用于大型程序的工具
抛出异常 throw
![](../../assets/2022-06-12-16-36-55.png)
![](../../assets/2022-06-12-16-37-22.png)
![](../../assets/2022-06-12-16-37-30.png)

捕捉异常 catch
![](../../assets/2022-06-12-16-38-06.png)
![](../../assets/2022-06-12-16-38-14.png)
![](../../assets/2022-06-12-16-38-21.png)

![](../../assets/2022-06-12-16-38-40.png)

![](../../assets/2022-06-12-16-39-00.png)

noexcept异常说明
![](../../assets/2022-06-12-16-41-03.png)
![](../../assets/2022-06-12-16-41-16.png)

命名空间
![](../../assets/2022-06-12-16-42-07.png)
![](../../assets/2022-06-12-16-42-26.png)
![](../../assets/2022-06-12-16-42-37.png)
![](../../assets/2022-06-12-16-42-44.png)
![](../../assets/2022-06-12-16-42-52.png)
![](../../assets/2022-06-12-16-44-02.png)

未命名的命名空间
![](../../assets/2022-06-12-16-45-55.png)
![](../../assets/2022-06-12-16-46-33.png)

命名空间别名
![](../../assets/2022-06-12-16-46-52.png)

using提示
![](../../assets/2022-06-12-16-48-03.png)

头文件与using声明或指示
![](../../assets/2022-06-12-16-49-33.png)

类、命名空间与作用域
![](../../assets/2022-06-12-16-50-04.png)

基于指针类型或引用类型的查找
![](../../assets/2022-06-12-16-51-07.png)

多重继承下的类作用域
![](../../assets/2022-06-12-16-51-31.png)

虚继承
![](../../assets/2022-06-12-16-52-01.png)

![](../../assets/2022-06-12-16-54-23.png)

使用虚基类
![](../../assets/2022-06-12-16-54-44.png)

![](../../assets/2022-06-12-16-55-00.png)

特殊工具与技术
重载new delete
![](../../assets/2022-06-12-16-55-33.png)

![](../../assets/2022-06-12-16-55-49.png)
![](../../assets/2022-06-12-16-56-03.png)

定位new表达式
![](../../assets/2022-06-12-16-57-26.png)
![](../../assets/2022-06-12-16-57-37.png)

显式的析构函数调用
![](../../assets/2022-06-12-16-57-53.png)

运行时类型识别
![](../../assets/2022-06-12-16-58-19.png)
![](../../assets/2022-06-12-16-59-37.png)
![](../../assets/2022-06-12-16-59-51.png)

typeid运算符 头文件typeinfo
![](../../assets/2022-06-12-17-04-20.png)

虚equal函数
![](../../assets/2022-06-12-17-04-55.png)

type_info类 头文件typeinfo
![](../../assets/2022-06-12-17-05-45.png)
![](../../assets/2022-06-12-17-05-55.png)

枚举类型
![](../../assets/2022-06-12-17-08-09.png)

类成员指针 使用成员指针
![](../../assets/2022-06-12-17-08-45.png)

使用成员指针的类型别名
![](../../assets/2022-06-12-17-09-05.png)

外层类之外定义一个嵌套类
![](../../assets/2022-06-12-17-09-42.png)

union 一种节省空间的类

匿名union
![](../../assets/2022-06-12-17-11-19.png)

局部类
![](../../assets/2022-06-12-17-11-46.png)

位域
![](../../assets/2022-06-12-17-12-16.png)
![](../../assets/2022-06-12-17-12-26.png)

volatile限定符 告诉编译器不应该对对象进行优化
![](../../assets/2022-06-12-17-12-41.png)
![](../../assets/2022-06-12-17-13-06.png)

extern "C"
![](../../assets/2022-06-12-17-13-31.png)

链接指示与头文件
![](../../assets/2022-06-12-17-14-18.png)
![](../../assets/2022-06-12-17-14-24.png)
![](../../assets/2022-06-12-17-14-33.png)

导出c++函数到其他语言
![](../../assets/2022-06-12-17-15-01.png)
![](../../assets/2022-06-12-17-14-41.png)

完